import{u as L,b as P,j as _}from"./index-BY28rWyY.js";import{L as B,F as I,S as D,i as N,B as z,j as M,I as F,C as H,k as W,l as v,g as q,m as Y,u as O}from"./Scene-BkJOb9up.js";import{u as J}from"./useGameFrame-4uNRX8cY.js";import{u as Z,g as R}from"./useMeteoData-jzjjA3_I.js";const S=new WeakMap;class j extends B{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,o,r,s){const n=new I(this.manager);n.setPath(this.path),n.setResponseType("arraybuffer"),n.setRequestHeader(this.requestHeader),n.setWithCredentials(this.withCredentials),n.load(e,t=>{this.parse(t,o,s)},r,s)}parse(e,o,r=()=>{}){this.decodeDracoFile(e,o,null,null,D,r).catch(r)}decodeDracoFile(e,o,r,s,n=N,t=()=>{}){const a={attributeIDs:r||this.defaultAttributeIDs,attributeTypes:s||this.defaultAttributeTypes,useUniqueIDs:!!r,vertexColorSpace:n};return this.decodeGeometry(e,a).then(o).catch(t)}decodeGeometry(e,o){const r=JSON.stringify(o);if(S.has(e)){const i=S.get(e);if(i.key===r)return i.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let s;const n=this.workerNextTaskID++,t=e.byteLength,a=this._getWorker(n,t).then(i=>(s=i,new Promise((f,c)=>{s._callbacks[n]={resolve:f,reject:c},s.postMessage({type:"decode",id:n,taskConfig:o,buffer:e},[e])}))).then(i=>this._createGeometry(i.geometry));return a.catch(()=>!0).then(()=>{s&&n&&this._releaseTask(s,n)}),S.set(e,{key:r,promise:a}),a}_createGeometry(e){const o=new z;e.index&&o.setIndex(new M(e.index.array,1));for(let r=0;r<e.attributes.length;r++){const{name:s,array:n,itemSize:t,stride:a,vertexColorSpace:i}=e.attributes[r];let f;if(t===a)f=new M(n,t);else{const c=new F(n,a);f=new v(c,t,0)}s==="color"&&(this._assignVertexColorSpace(f,i),f.normalized=!(n instanceof Float32Array)),o.setAttribute(s,f)}return o}_assignVertexColorSpace(e,o){if(o!==D)return;const r=new H;for(let s=0,n=e.count;s<n;s++)r.fromBufferAttribute(e,s),W.colorSpaceToWorking(r,D),e.setXYZ(s,r.r,r.g,r.b)}_loadLibrary(e,o){const r=new I(this.manager);return r.setPath(this.decoderPath),r.setResponseType(o),r.setWithCredentials(this.withCredentials),new Promise((s,n)=>{r.load(e,s,void 0,n)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",o=[];return e?o.push(this._loadLibrary("draco_decoder.js","text")):(o.push(this._loadLibrary("draco_wasm_wrapper.js","text")),o.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(o).then(r=>{const s=r[0];e||(this.decoderConfig.wasmBinary=r[1]);const n=V.toString(),t=["/* draco decoder */",s,"","/* worker */",n.substring(n.indexOf("{")+1,n.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([t]))}),this.decoderPending}_getWorker(e,o){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const s=new Worker(this.workerSourceURL);s._callbacks={},s._taskCosts={},s._taskLoad=0,s.postMessage({type:"init",decoderConfig:this.decoderConfig}),s.onmessage=function(n){const t=n.data;switch(t.type){case"decode":s._callbacks[t.id].resolve(t);break;case"error":s._callbacks[t.id].reject(t);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+t.type+'"')}},this.workerPool.push(s)}else this.workerPool.sort(function(s,n){return s._taskLoad>n._taskLoad?-1:1});const r=this.workerPool[this.workerPool.length-1];return r._taskCosts[e]=o,r._taskLoad+=o,r})}_releaseTask(e,o){e._taskLoad-=e._taskCosts[o],delete e._callbacks[o],delete e._taskCosts[o]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function V(){let h,e;onmessage=function(t){const a=t.data;switch(a.type){case"init":h=a.decoderConfig,e=new Promise(function(c){h.onModuleLoaded=function(d){c({draco:d})},DracoDecoderModule(h)});break;case"decode":const i=a.buffer,f=a.taskConfig;e.then(c=>{const d=c.draco,l=new d.Decoder;try{const u=o(d,l,new Int8Array(i),f),g=u.attributes.map(m=>m.array.buffer);u.index&&g.push(u.index.array.buffer),self.postMessage({type:"decode",id:a.id,geometry:u},g)}catch(u){console.error(u),self.postMessage({type:"error",id:a.id,error:u.message})}finally{d.destroy(l)}});break}};function o(t,a,i,f){const c=f.attributeIDs,d=f.attributeTypes;let l,u;const g=a.GetEncodedGeometryType(i);if(g===t.TRIANGULAR_MESH)l=new t.Mesh,u=a.DecodeArrayToMesh(i,i.byteLength,l);else if(g===t.POINT_CLOUD)l=new t.PointCloud,u=a.DecodeArrayToPointCloud(i,i.byteLength,l);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!u.ok()||l.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+u.error_msg());const m={index:null,attributes:[]};for(const y in c){const w=self[d[y]];let p,b;if(f.useUniqueIDs)b=c[y],p=a.GetAttributeByUniqueId(l,b);else{if(b=a.GetAttributeId(l,t[c[y]]),b===-1)continue;p=a.GetAttribute(l,b)}const k=s(t,a,l,y,w,p);y==="color"&&(k.vertexColorSpace=f.vertexColorSpace),m.attributes.push(k)}return g===t.TRIANGULAR_MESH&&(m.index=r(t,a,l)),t.destroy(l),m}function r(t,a,i){const c=i.num_faces()*3,d=c*4,l=t._malloc(d);a.GetTrianglesUInt32Array(i,d,l);const u=new Uint32Array(t.HEAPF32.buffer,l,c).slice();return t._free(l),{array:u,itemSize:1}}function s(t,a,i,f,c,d){const l=i.num_points(),u=d.num_components(),g=n(t,c),m=u*c.BYTES_PER_ELEMENT,y=Math.ceil(m/4)*4,w=y/c.BYTES_PER_ELEMENT,p=l*m,b=l*y,k=t._malloc(p);a.GetAttributeDataArrayForAllPoints(i,d,g,p,k);const A=new c(t.HEAPF32.buffer,k,p/c.BYTES_PER_ELEMENT);let T;if(m===y)T=A.slice();else{T=new c(b/c.BYTES_PER_ELEMENT);let E=0;for(let C=0,G=A.length;C<G;C++){for(let x=0;x<u;x++)T[E+x]=A[C*u+x];E+=w}}return t._free(k),{name:f,count:l,itemSize:u,array:T,stride:w}}function n(t,a){switch(a){case Float32Array:return t.DT_FLOAT32;case Int8Array:return t.DT_INT8;case Int16Array:return t.DT_INT16;case Int32Array:return t.DT_INT32;case Uint8Array:return t.DT_UINT8;case Uint16Array:return t.DT_UINT16;case Uint32Array:return t.DT_UINT32}}}const X="/galaxy-shooting/pr/83/assets/Meteolite1-R1JTySCP.drc",K="/galaxy-shooting/pr/83/assets/Meteolite2-D-5ZCOOZ.drc",Q="/galaxy-shooting/pr/83/assets/Meteolite3-0_Pc1s3G.drc",$="/galaxy-shooting/pr/83/assets/Meteolite4-DExg_RkS.drc",ee=h=>{h instanceof j&&h.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.7/")},U=P.memo(({guid:h,geometry:e,position:o,rotation:r,scale:s,color:n,...t})=>{const a=P.useRef(null),i=O(d=>d.viewport.aspect),f=O(d=>d.raycaster),c=L(d=>d.replaceMeteo);return J(({camera:d})=>{if(!a.current)return;const l=L.getState().cam.position,u=f.intersectObject(a.current,!0).length>0,g=a.current.position.z>l.z;if(!u&&!g)return;const m=d.near+5,y=R({min:.5,max:2}),w={x:y,y,z:y},p={x:R({min:-m*i/2,max:m*i/2}),y:R({min:-m/2,max:m/2}),z:o.z-d.far},b={x:r.x+Math.PI*.05,y:r.y+Math.PI*.05,z:r.z+Math.PI*.05};c({...t,guid:h,scale:g?w:s,position:g?p:o,rotation:u?b:r})}),_.jsxs("mesh",{ref:a,position:[o.x,o.y,o.z],rotation:[r.x,r.y,r.z],scale:[s.x,s.y,s.z],children:[_.jsx("bufferGeometry",{attach:"geometry",...e}),_.jsx("meshLambertMaterial",{attach:"material",color:n||"lightblue",transparent:!0})]})},(h,e)=>h.rotation.x===e.rotation.x&&h.rotation.y===e.rotation.y&&h.rotation.z===e.rotation.z&&h.position.x===e.position.x&&h.position.y===e.position.y&&h.position.z===e.position.z&&h.color===e.color),te=new Y,ae=({num:h})=>{const e=L(t=>t.load.meteolites),o=L(t=>t.meteos),r=L(t=>t.updateLoad),s=q(j,[X,K,Q,$],ee),{set:n}=Z({patternNum:s.length});return P.useLayoutEffect(()=>{!s||e||(n(h),r({meteolites:!0}))},[n,e,s,h,r]),_.jsx(_.Fragment,{children:Object.values(o).map(t=>_.jsx(P.Suspense,{fallback:_.jsx(U,{geometry:te,...t}),children:_.jsx(U,{geometry:s[t.pattern],...t})},t.guid))})};export{ae as default};
