import{b as L,u as y,j as _}from"./index-CMnVFo_k.js";import{L as H,F as J,C as q,S as W,G as X,B as O,a as S,b as F,M as G,P as C,c as Z,d as D,e as P,f as U,V as z,u as R,g as K,h as Q}from"./Scene-CZrXUGXj.js";import{u as Y}from"./useGameFrame-DPUcyCxG.js";import{t as $}from"./collision-XhCMdEdk.js";const ee=/^[og]\s*(.+)?/,te=/^mtllib /,se=/^usemtl /,ie=/^usemap /,k=/\s+/,B=new z,A=new z,N=new z,T=new z,x=new z,I=new q;function ne(){const V={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(s,e){if(this.object&&this.object.fromDeclaration===!1){this.object.name=s,this.object.fromDeclaration=e!==!1;return}const i=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:s||"",fromDeclaration:e!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(t,n){const c=this._finalize(!1);c&&(c.inherited||c.groupCount<=0)&&this.materials.splice(c.index,1);const d={index:this.materials.length,name:t||"",mtllib:Array.isArray(n)&&n.length>0?n[n.length-1]:"",smooth:c!==void 0?c.smooth:this.smooth,groupStart:c!==void 0?c.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(g){const a={index:typeof g=="number"?g:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return a.clone=this.clone.bind(a),a}};return this.materials.push(d),d},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(t){const n=this.currentMaterial();if(n&&n.groupEnd===-1&&(n.groupEnd=this.geometry.vertices.length/3,n.groupCount=n.groupEnd-n.groupStart,n.inherited=!1),t&&this.materials.length>1)for(let c=this.materials.length-1;c>=0;c--)this.materials[c].groupCount<=0&&this.materials.splice(c,1);return t&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),n}},i&&i.name&&typeof i.clone=="function"){const t=i.clone(0);t.inherited=!0,this.object.materials.push(t)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(s,e){const i=parseInt(s,10);return(i>=0?i-1:i+e/3)*3},parseNormalIndex:function(s,e){const i=parseInt(s,10);return(i>=0?i-1:i+e/3)*3},parseUVIndex:function(s,e){const i=parseInt(s,10);return(i>=0?i-1:i+e/2)*2},addVertex:function(s,e,i){const t=this.vertices,n=this.object.geometry.vertices;n.push(t[s+0],t[s+1],t[s+2]),n.push(t[e+0],t[e+1],t[e+2]),n.push(t[i+0],t[i+1],t[i+2])},addVertexPoint:function(s){const e=this.vertices;this.object.geometry.vertices.push(e[s+0],e[s+1],e[s+2])},addVertexLine:function(s){const e=this.vertices;this.object.geometry.vertices.push(e[s+0],e[s+1],e[s+2])},addNormal:function(s,e,i){const t=this.normals,n=this.object.geometry.normals;n.push(t[s+0],t[s+1],t[s+2]),n.push(t[e+0],t[e+1],t[e+2]),n.push(t[i+0],t[i+1],t[i+2])},addFaceNormal:function(s,e,i){const t=this.vertices,n=this.object.geometry.normals;B.fromArray(t,s),A.fromArray(t,e),N.fromArray(t,i),x.subVectors(N,A),T.subVectors(B,A),x.cross(T),x.normalize(),n.push(x.x,x.y,x.z),n.push(x.x,x.y,x.z),n.push(x.x,x.y,x.z)},addColor:function(s,e,i){const t=this.colors,n=this.object.geometry.colors;t[s]!==void 0&&n.push(t[s+0],t[s+1],t[s+2]),t[e]!==void 0&&n.push(t[e+0],t[e+1],t[e+2]),t[i]!==void 0&&n.push(t[i+0],t[i+1],t[i+2])},addUV:function(s,e,i){const t=this.uvs,n=this.object.geometry.uvs;n.push(t[s+0],t[s+1]),n.push(t[e+0],t[e+1]),n.push(t[i+0],t[i+1])},addDefaultUV:function(){const s=this.object.geometry.uvs;s.push(0,0),s.push(0,0),s.push(0,0)},addUVLine:function(s){const e=this.uvs;this.object.geometry.uvs.push(e[s+0],e[s+1])},addFace:function(s,e,i,t,n,c,d,g,a){const h=this.vertices.length;let r=this.parseVertexIndex(s,h),l=this.parseVertexIndex(e,h),u=this.parseVertexIndex(i,h);if(this.addVertex(r,l,u),this.addColor(r,l,u),d!==void 0&&d!==""){const p=this.normals.length;r=this.parseNormalIndex(d,p),l=this.parseNormalIndex(g,p),u=this.parseNormalIndex(a,p),this.addNormal(r,l,u)}else this.addFaceNormal(r,l,u);if(t!==void 0&&t!==""){const p=this.uvs.length;r=this.parseUVIndex(t,p),l=this.parseUVIndex(n,p),u=this.parseUVIndex(c,p),this.addUV(r,l,u),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(s){this.object.geometry.type="Points";const e=this.vertices.length;for(let i=0,t=s.length;i<t;i++){const n=this.parseVertexIndex(s[i],e);this.addVertexPoint(n),this.addColor(n)}},addLineGeometry:function(s,e){this.object.geometry.type="Line";const i=this.vertices.length,t=this.uvs.length;for(let n=0,c=s.length;n<c;n++)this.addVertexLine(this.parseVertexIndex(s[n],i));for(let n=0,c=e.length;n<c;n++)this.addUVLine(this.parseUVIndex(e[n],t))}};return V.startObject("",!1),V}class oe extends H{constructor(s){super(s),this.materials=null}load(s,e,i,t){const n=this,c=new J(this.manager);c.setPath(this.path),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(s,function(d){try{e(n.parse(d))}catch(g){t?t(g):console.error(g),n.manager.itemError(s)}},i,t)}setMaterials(s){return this.materials=s,this}parse(s){const e=new ne;s.indexOf(`\r
`)!==-1&&(s=s.replace(/\r\n/g,`
`)),s.indexOf(`\\
`)!==-1&&(s=s.replace(/\\\n/g,""));const i=s.split(`
`);let t=[];for(let d=0,g=i.length;d<g;d++){const a=i[d].trimStart();if(a.length===0)continue;const h=a.charAt(0);if(h!=="#")if(h==="v"){const r=a.split(k);switch(r[0]){case"v":e.vertices.push(parseFloat(r[1]),parseFloat(r[2]),parseFloat(r[3])),r.length>=7?(I.setRGB(parseFloat(r[4]),parseFloat(r[5]),parseFloat(r[6]),W),e.colors.push(I.r,I.g,I.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(r[1]),parseFloat(r[2]),parseFloat(r[3]));break;case"vt":e.uvs.push(parseFloat(r[1]),parseFloat(r[2]));break}}else if(h==="f"){const l=a.slice(1).trim().split(k),u=[];for(let o=0,m=l.length;o<m;o++){const b=l[o];if(b.length>0){const v=b.split("/");u.push(v)}}const p=u[0];for(let o=1,m=u.length-1;o<m;o++){const b=u[o],v=u[o+1];e.addFace(p[0],b[0],v[0],p[1],b[1],v[1],p[2],b[2],v[2])}}else if(h==="l"){const r=a.substring(1).trim().split(" ");let l=[];const u=[];if(a.indexOf("/")===-1)l=r;else for(let p=0,o=r.length;p<o;p++){const m=r[p].split("/");m[0]!==""&&l.push(m[0]),m[1]!==""&&u.push(m[1])}e.addLineGeometry(l,u)}else if(h==="p"){const l=a.slice(1).trim().split(" ");e.addPointGeometry(l)}else if((t=ee.exec(a))!==null){const r=(" "+t[0].slice(1).trim()).slice(1);e.startObject(r)}else if(se.test(a))e.object.startMaterial(a.substring(7).trim(),e.materialLibraries);else if(te.test(a))e.materialLibraries.push(a.substring(7).trim());else if(ie.test(a))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(h==="s"){if(t=a.split(" "),t.length>1){const l=t[1].trim().toLowerCase();e.object.smooth=l!=="0"&&l!=="off"}else e.object.smooth=!0;const r=e.object.currentMaterial();r&&(r.smooth=e.object.smooth)}else{if(a==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+a+'"')}}e.finalize();const n=new X;if(n.materialLibraries=[].concat(e.materialLibraries),!(e.objects.length===1&&e.objects[0].geometry.vertices.length===0)===!0)for(let d=0,g=e.objects.length;d<g;d++){const a=e.objects[d],h=a.geometry,r=a.materials,l=h.type==="Line",u=h.type==="Points";let p=!1;if(h.vertices.length===0)continue;const o=new O;o.setAttribute("position",new S(h.vertices,3)),h.normals.length>0&&o.setAttribute("normal",new S(h.normals,3)),h.colors.length>0&&(p=!0,o.setAttribute("color",new S(h.colors,3))),h.hasUVIndices===!0&&o.setAttribute("uv",new S(h.uvs,2));const m=[];for(let v=0,M=r.length;v<M;v++){const j=r[v],E=j.name+"_"+j.smooth+"_"+p;let f=e.materials[E];if(this.materials!==null){if(f=this.materials.create(j.name),l&&f&&!(f instanceof F)){const w=new F;G.prototype.copy.call(w,f),w.color.copy(f.color),f=w}else if(u&&f&&!(f instanceof C)){const w=new C({size:10,sizeAttenuation:!1});G.prototype.copy.call(w,f),w.color.copy(f.color),w.map=f.map,f=w}}f===void 0&&(l?f=new F:u?f=new C({size:1,sizeAttenuation:!1}):f=new Z,f.name=j.name,f.flatShading=!j.smooth,f.vertexColors=p,e.materials[E]=f),m.push(f)}let b;if(m.length>1){for(let v=0,M=r.length;v<M;v++){const j=r[v];o.addGroup(j.groupStart,j.groupCount,v)}l?b=new D(o,m):u?b=new P(o,m):b=new U(o,m)}else l?b=new D(o,m[0]):u?b=new P(o,m[0]):b=new U(o,m[0]);b.name=a.name,n.add(b)}else if(e.vertices.length>0){const d=new C({size:1,sizeAttenuation:!1}),g=new O;g.setAttribute("position",new S(e.vertices,3)),e.colors.length>0&&e.colors[0]!==void 0&&(g.setAttribute("color",new S(e.colors,3)),d.vertexColors=!0);const a=new P(g,d);n.add(a)}return n}}const re="/galaxy-shooting/pr/16/assets/spaceShip-D8CZXyvf.obj",ae=.1,ce=new U(new Q),de=L.memo(()=>{const V=R(o=>o.pointer),s=R(o=>o.viewport.aspect),e=y(o=>o.spaceShip.position),i=y(o=>o.spaceShip.rotation),t=y(o=>o.spaceShip.scale),n=y(o=>o.spaceShip.flightSpeed),c=y(o=>o.spaceShip.isRotation),d=y(o=>o.spaceShip.isClashed),g=y(o=>o.meteos),a=y(o=>o.load.spaceShip),h=y(o=>o.updateSpaceShip),r=y(o=>o.updateLoad),l=L.useCallback(()=>{h({isRotation:!c})},[c,h]);L.useLayoutEffect(()=>(window.addEventListener("click",l),()=>{window.removeEventListener("click",l)}),[l]);const u=K(oe,re),p=L.useCallback(o=>{h({rotation:{x:o.rotation.x-Math.PI,y:o.rotation.y,z:o.rotation.z},scale:{x:o.scale.x/2,y:o.scale.y/2,z:o.scale.z/2}})},[h]);return L.useLayoutEffect(()=>{!u||a||(p(u),r({spaceShip:!0}))},[p,a,u,r]),Y(()=>{if(d)return;const o=V.x/2,m=V.y/2;h({isClashed:Object.values(g).some(b=>$(b,{position:e,scale:t})),position:{...e,x:o*s*14,y:m*14,z:e.z-n},rotation:{...i,z:c?i.z+ae:i.z}})}),_.jsxs(L.Fragment,{children:[_.jsx(L.Suspense,{fallback:_.jsx("primitive",{object:ce}),children:_.jsx("primitive",{object:u,position:[e.x,e.y,e.z],rotation:[i.x,i.y,i.z],scale:[t.x,t.y,t.z]})}),_.jsx("pointLight",{position:[e.x,e.y,e.z+100],distance:100,intensity:10})]})});export{de as default};
