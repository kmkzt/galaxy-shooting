import{u as L,b as A,j as _}from"./index-C-jvRl33.js";import{L as B,F as I,S as D,i as N,B as z,j as M,I as F,C as H,k as W,l as v,g as q,m as Y,u as O}from"./Scene-Cfe5Xz-g.js";import{u as J}from"./useGameFrame-CphTMHYQ.js";import{u as Z,g as R}from"./useMeteoData-BApQBJ4I.js";const S=new WeakMap;class j extends B{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,o,r,s){const n=new I(this.manager);n.setPath(this.path),n.setResponseType("arraybuffer"),n.setRequestHeader(this.requestHeader),n.setWithCredentials(this.withCredentials),n.load(e,t=>{this.parse(t,o,s)},r,s)}parse(e,o,r=()=>{}){this.decodeDracoFile(e,o,null,null,D,r).catch(r)}decodeDracoFile(e,o,r,s,n=N,t=()=>{}){const i={attributeIDs:r||this.defaultAttributeIDs,attributeTypes:s||this.defaultAttributeTypes,useUniqueIDs:!!r,vertexColorSpace:n};return this.decodeGeometry(e,i).then(o).catch(t)}decodeGeometry(e,o){const r=JSON.stringify(o);if(S.has(e)){const a=S.get(e);if(a.key===r)return a.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let s;const n=this.workerNextTaskID++,t=e.byteLength,i=this._getWorker(n,t).then(a=>(s=a,new Promise((f,c)=>{s._callbacks[n]={resolve:f,reject:c},s.postMessage({type:"decode",id:n,taskConfig:o,buffer:e},[e])}))).then(a=>this._createGeometry(a.geometry));return i.catch(()=>!0).then(()=>{s&&n&&this._releaseTask(s,n)}),S.set(e,{key:r,promise:i}),i}_createGeometry(e){const o=new z;e.index&&o.setIndex(new M(e.index.array,1));for(let r=0;r<e.attributes.length;r++){const{name:s,array:n,itemSize:t,stride:i,vertexColorSpace:a}=e.attributes[r];let f;if(t===i)f=new M(n,t);else{const c=new F(n,i);f=new v(c,t,0)}s==="color"&&(this._assignVertexColorSpace(f,a),f.normalized=!(n instanceof Float32Array)),o.setAttribute(s,f)}return o}_assignVertexColorSpace(e,o){if(o!==D)return;const r=new H;for(let s=0,n=e.count;s<n;s++)r.fromBufferAttribute(e,s),W.colorSpaceToWorking(r,D),e.setXYZ(s,r.r,r.g,r.b)}_loadLibrary(e,o){const r=new I(this.manager);return r.setPath(this.decoderPath),r.setResponseType(o),r.setWithCredentials(this.withCredentials),new Promise((s,n)=>{r.load(e,s,void 0,n)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",o=[];return e?o.push(this._loadLibrary("draco_decoder.js","text")):(o.push(this._loadLibrary("draco_wasm_wrapper.js","text")),o.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(o).then(r=>{const s=r[0];e||(this.decoderConfig.wasmBinary=r[1]);const n=V.toString(),t=["/* draco decoder */",s,"","/* worker */",n.substring(n.indexOf("{")+1,n.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([t]))}),this.decoderPending}_getWorker(e,o){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const s=new Worker(this.workerSourceURL);s._callbacks={},s._taskCosts={},s._taskLoad=0,s.postMessage({type:"init",decoderConfig:this.decoderConfig}),s.onmessage=function(n){const t=n.data;switch(t.type){case"decode":s._callbacks[t.id].resolve(t);break;case"error":s._callbacks[t.id].reject(t);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+t.type+'"')}},this.workerPool.push(s)}else this.workerPool.sort(function(s,n){return s._taskLoad>n._taskLoad?-1:1});const r=this.workerPool[this.workerPool.length-1];return r._taskCosts[e]=o,r._taskLoad+=o,r})}_releaseTask(e,o){e._taskLoad-=e._taskCosts[o],delete e._callbacks[o],delete e._taskCosts[o]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function V(){let h,e;onmessage=function(t){const i=t.data;switch(i.type){case"init":h=i.decoderConfig,e=new Promise(function(c){h.onModuleLoaded=function(l){c({draco:l})},DracoDecoderModule(h)});break;case"decode":const a=i.buffer,f=i.taskConfig;e.then(c=>{const l=c.draco,d=new l.Decoder;try{const u=o(l,d,new Int8Array(a),f),p=u.attributes.map(m=>m.array.buffer);u.index&&p.push(u.index.array.buffer),self.postMessage({type:"decode",id:i.id,geometry:u},p)}catch(u){console.error(u),self.postMessage({type:"error",id:i.id,error:u.message})}finally{l.destroy(d)}});break}};function o(t,i,a,f){const c=f.attributeIDs,l=f.attributeTypes;let d,u;const p=i.GetEncodedGeometryType(a);if(p===t.TRIANGULAR_MESH)d=new t.Mesh,u=i.DecodeArrayToMesh(a,a.byteLength,d);else if(p===t.POINT_CLOUD)d=new t.PointCloud,u=i.DecodeArrayToPointCloud(a,a.byteLength,d);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!u.ok()||d.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+u.error_msg());const m={index:null,attributes:[]};for(const y in c){const w=self[l[y]];let g,b;if(f.useUniqueIDs)b=c[y],g=i.GetAttributeByUniqueId(d,b);else{if(b=i.GetAttributeId(d,t[c[y]]),b===-1)continue;g=i.GetAttribute(d,b)}const k=s(t,i,d,y,w,g);y==="color"&&(k.vertexColorSpace=f.vertexColorSpace),m.attributes.push(k)}return p===t.TRIANGULAR_MESH&&(m.index=r(t,i,d)),t.destroy(d),m}function r(t,i,a){const c=a.num_faces()*3,l=c*4,d=t._malloc(l);i.GetTrianglesUInt32Array(a,l,d);const u=new Uint32Array(t.HEAPF32.buffer,d,c).slice();return t._free(d),{array:u,itemSize:1}}function s(t,i,a,f,c,l){const d=a.num_points(),u=l.num_components(),p=n(t,c),m=u*c.BYTES_PER_ELEMENT,y=Math.ceil(m/4)*4,w=y/c.BYTES_PER_ELEMENT,g=d*m,b=d*y,k=t._malloc(g);i.GetAttributeDataArrayForAllPoints(a,l,p,g,k);const C=new c(t.HEAPF32.buffer,k,g/c.BYTES_PER_ELEMENT);let T;if(m===y)T=C.slice();else{T=new c(b/c.BYTES_PER_ELEMENT);let E=0;for(let x=0,G=C.length;x<G;x++){for(let P=0;P<u;P++)T[E+P]=C[x*u+P];E+=w}}return t._free(k),{name:f,count:d,itemSize:u,array:T,stride:w}}function n(t,i){switch(i){case Float32Array:return t.DT_FLOAT32;case Int8Array:return t.DT_INT8;case Int16Array:return t.DT_INT16;case Int32Array:return t.DT_INT32;case Uint8Array:return t.DT_UINT8;case Uint16Array:return t.DT_UINT16;case Uint32Array:return t.DT_UINT32}}}const X="/assets/Meteolite1-R1JTySCP.drc",K="/assets/Meteolite2-D-5ZCOOZ.drc",Q="/assets/Meteolite3-0_Pc1s3G.drc",$="/assets/Meteolite4-DExg_RkS.drc",ee=h=>{h instanceof j&&h.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.7/")},U=A.memo(({guid:h,geometry:e,position:o,rotation:r,scale:s,color:n,...t})=>{const i=A.useRef(null),a=O(l=>l.viewport.aspect),f=O(l=>l.raycaster),c=L(l=>l.replaceMeteo);return J(({camera:l})=>{if(!i.current)return;const d=L.getState().cam.position,u=f.intersectObject(i.current,!0).length>0,p=i.current.position.z>d.z;if(!u&&!p)return;const m=l.near+5,y=R({min:.5,max:2}),w={x:y,y,z:y},g={x:R({min:-m*a/2,max:m*a/2}),y:R({min:-m/2,max:m/2}),z:o.z-l.far},b={x:r.x+Math.PI*.05,y:r.y+Math.PI*.05,z:r.z+Math.PI*.05};c({...t,guid:h,scale:p?w:s,position:p?g:o,rotation:u?b:r})}),_.jsxs("mesh",{ref:i,position:[o.x,o.y,o.z],rotation:[r.x,r.y,r.z],scale:[s.x,s.y,s.z],children:[_.jsx("bufferGeometry",{attach:"geometry",...e}),_.jsx("meshLambertMaterial",{attach:"material",color:n||"lightblue",transparent:!0})]})},(h,e)=>h.rotation.x===e.rotation.x&&h.rotation.y===e.rotation.y&&h.rotation.z===e.rotation.z&&h.position.x===e.position.x&&h.position.y===e.position.y&&h.position.z===e.position.z&&h.color===e.color),te=new Y,ie=({num:h})=>{const e=L(t=>t.load.meteolites),o=L(t=>t.meteos),r=L(t=>t.updateLoad),s=q(j,[X,K,Q,$],ee),{set:n}=Z({patternNum:s.length});return A.useLayoutEffect(()=>{!s||e||(n(h),r({meteolites:!0}))},[n,e,s,h,r]),_.jsx(_.Fragment,{children:Object.values(o).map(t=>_.jsx(A.Suspense,{fallback:_.jsx(U,{geometry:te,...t}),children:_.jsx(U,{geometry:s[t.pattern],...t})},t.guid))})};export{ie as default};
